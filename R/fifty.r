#' @title
#' Calculate the time of 50\% abundance of centroids of the clusters.
#'
#' @param clustered A fclust object containing the clustering details.
#'
#' @return A matrix, where each row represents an event. It contains for each event, the cluster number, (x (time), y (abundance)) coordinates and direction of crossing.
#'
#'
#' @importFrom methods is
#'
#'
#' @seealso \code{\link[e1071]{cmeans}} for clustering time profiles.
#'
#' @export
calc50crossing <- function(clustered){

	stopifnot(is(clustered, "fclust"))
	mat_fiftyPoints <- matrix(ncol=4)

	for (clusNum in 1:nrow(clustered$center)){
		# get mid_point on y axis
		y_max <- max(clustered$center[clusNum,])
		y_min <- min(clustered$center[clusNum,])

		y_50 <- (y_max + y_min)/2
		# print(c(y_max, y_50, y_min))

		# find intervals and store
		for (j in 2:ncol(clustered$center)){
			if (y_50 >= clustered$center[clusNum,j-1] && y_50 <= clustered$center[clusNum,j]){
				# 50 is crossed here in phos direction
				x_50 <- getMidX((j-1), clustered$center[clusNum,j-1], j, clustered$center[clusNum,j], y_50)
				mat_fiftyPoints <- addToMatrix(mat_fiftyPoints, clusNum, x_50, y_50, 1)
				# print(mat_fiftyPoints)
			}
			else if (y_50 <= clustered$center[clusNum,j-1] && y_50 >= clustered$center[clusNum,j]) {
				# 50 is crossed here in dephos direction
				# getMidX()
				x_50 <- getMidX((j-1), clustered$center[clusNum,j-1], j, clustered$center[clusNum,j], y_50)
				mat_fiftyPoints <- addToMatrix(mat_fiftyPoints, clusNum, x_50, y_50, -1)
			}
		}
	}

	mat_fiftyPoints <- mat_fiftyPoints[-1,]
}


#' @title
#' Overlays the 50\% abundance crossings on the Z-score heatmap.
#'
#' @param list_concTpSummary Z-scores and p-values extracted from tukey-constrasts for glm's of each cluster. Obtained by running the "summaryGetZP" function.
#' @param significanceTh P-value cutoff. This value ranges between 0 and 1. Generally, the threshold of p<0.5 is considered significant. This threshold can be reduced to, for example 0.01, 0.05 or 0.001, for only plotting the highly significant z-scores. To plot all z-scores, the treshold can be set to 1.
#' @param mat_fiftyPoints A matrix containing the event information generated by running the "calc50crossing" function.
#'
#'
#'
#' @return Displays a plot and returns a matrix, with z-scores masked (NA) according to the signficance threshold specified.
#'
#' @importFrom methods is
#' @importFrom gplots heatmap.2
#' @importFrom grDevices colorRampPalette
#' @importFrom graphics segments
#'
#'
#' @seealso \code{\link{plotZP}}, \code{\link{summaryGetZP}}, \code{\link{calc50crossing}}
#'
#' @export
plotZP_fifty <- function(list_concTpSummary, mat_fiftyPoints, significanceTh=0.5){

	stopifnot(is(list_concTpSummary, "summary.clusterChange"), (significanceTh >0 && significanceTh <= 1), is(mat_fiftyPoints, "matrix"))

	segs <- calcSegsOfCentroids(mat_fiftyPoints) # need to add to global, for graphics::segments to find.
	assign("segs", segs, envir=.GlobalEnv)
	theSignifs <- list_concTpSummary[[2]] < significanceTh

	matToPlot <- list_concTpSummary[[1]]

	rwb <- grDevices::colorRampPalette(colors = c("blue", "white", "red"))(n=299)


	if (!all(theSignifs)){
		zscore_largest <- ceiling(max(c(abs(min(matToPlot)), abs(max(matToPlot)))))
		theBreaks <- seq(-zscore_largest, zscore_largest, length.out=299)

		zscore_largest_noSignif <- max(c(abs(max(matToPlot[!theSignifs])), abs(min(matToPlot[!theSignifs]))))
		idx_forGray50 <- theBreaks <= zscore_largest_noSignif & theBreaks >= -zscore_largest_noSignif


		rwb[idx_forGray50] <- "gray50"

		matToPlot[!theSignifs] <- NA
	}


	titleTxt = paste("Significant changes\n(z-values of intervals,\n with significance p \u003C", significanceTh, ")", sep="")
	# print(titleTxt)

	gplots::heatmap.2(matToPlot, main=titleTxt, xlab="Time interval", ylab="Cluster", Rowv=FALSE, Colv=FALSE, dendrogram="none", col=rwb, na.color="gray50", tracecol=NA, density.info="none", sepcolor="gray50", sepwidth=c(0.001, 0.001), colsep=0:ncol(matToPlot), rowsep=0:nrow(matToPlot), srtCol=45, add.expr=graphics::segments(x0=segs[[1]], y0=segs[[2]], x1=segs[[1]], y1=segs[[4]], col=segs[[5]], lwd=3))

	return (matToPlot)
}


################################## AUXILLARY





getMidX <- function(x1, y1, x2, y2, y_50){
	m <- (y2 - y1)/(x2 - x1)
	x_50 <- x1 + ((y_50 - y1)/m)
	return (x_50)
}

addToMatrix <- function(theMat, clusNum, x_50, y_50, direction){
	theMat <- rbind(theMat, c(clusNum, x_50, y_50, direction))
	return (theMat)
}


calcSegsOfCentroids <- function(mat_fiftyPoints){

	totalNumCluster <- max(mat_fiftyPoints[,cols_matFifty$col_clus]) + 0.5
	y_val = totalNumCluster

	x <- c(); y <- c(); x1 <- c(); y1 <- c(); colors <- c();

	for (rowNum in 1:nrow(mat_fiftyPoints)){
		x[rowNum] <- mat_fiftyPoints[rowNum, cols_matFifty$col_x] - 0.5
		x1[rowNum] <- mat_fiftyPoints[rowNum, cols_matFifty$col_x] - 0.5
		y[rowNum] <- ((totalNumCluster - (mat_fiftyPoints[rowNum, cols_matFifty$col_clus])) * 1)
		y1[rowNum] <- ((totalNumCluster - (mat_fiftyPoints[rowNum, cols_matFifty$col_clus] - 1)) * 1)

		if (mat_fiftyPoints[rowNum, cols_matFifty$col_dir] == 1){
			colors[rowNum] <- "#8B0000"
		}
		else{
			colors[rowNum] <- "#00008B"
		}
	}

	return(list(x, y, x1, y1, colors))
}
