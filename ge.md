# Demonstration on a gene expression dataset

In this document, we demonstrate how our package can be utilised to order gene expression clusters.

### Dataset

We utilise the dataset made available by Ma *et al.* [1]. We downloaded the raw data from GEO (Gene Expression Omnibus) with the identifier GSE40565 and considered only the time-series arrays. We then obtained the differentially expressed genes from the seven time points (including basal) by following the section 'Microarray analysis' in Ma *et al.* [1]. This resulted in 2,566 profiles, which we make available as a sample dataset in this package.  

### Workflow

The work flow is very similar to the workflow for the time-series phosphoproteomics datasets.

#### 1. Load the dataset and standardise it

```R
# Load the data.
data(ge)


# Standardisation
tmp <- sweep(ge.temporal.changed, 1, apply(ge.temporal.changed, 1, mean), FUN="-")
ge.stand <- sweep(tmp, 1, apply(ge.temporal.changed, 1, sd), FUN="/")
ge.stand <- as.matrix(ge.stand)
remove(tmp)
```

#### 2. Clustering using Mfuzz
The next step is to cluster these data. For this data sets, we generate 20 clusters (as this number of clusters were shown to be optimal in the original article [1]).

We utilize the `cmeans` function made available by the Mfuzz package to partition these data.


```R
library(Mfuzz)

mfuzzObj <- cmeans(ge.stand, centers=20,  iter.max=1000, m=1.25) # paper, 2014 Ma et al. partitions into 20 clusters.

# Plotting the clusters
plotClusters(ge.stand, mfuzzObj$cluster)
```

![Mfuzz clustering](images/Ge/ge_clusters.png)
Fig. 1: Clusters of gene expression dataset.  



#### 3. Quantifying change within clusters

To quantify which intervals are significantly changing and in which direction, regression can be made use of. Here, we model the profiles in each cluster as a generalized linear model, where the response is the standardised abundance, and the predictors are the genes and time points. Generalized linear models assume normality, hence, visually inspect the PDF file generated by the `clusTpDistributions` function.

```R
# Generate a PDF file containing the distributions of standandardized abundances at each time point for each cluster. Each distribution should be approximately normally distributed.
clusTpDistributions(ge.stand, mfuzzObj$cluster, outfile="ge_tpDist.pdf") # See example file: images/Ge/ge_tpDist.pdf).

# For each cluster, a linear model is formulated (where standardized ratio is the response) and time points along with the profile itself, are predictors; the results of the post hoc Tukey contrasting timepoints are presented.
glmTukeyForEachClus <- calcClusterChng(ge.stand, mfuzzObj$cluster)

# Summarizes and returns two matrices containing post hoc Tukey z-scores and p-values for consecutive time intervals.
glmTukeyForEachClus.summary <- summaryGetZP(glmTukeyForEachClus, ge.stand)

# Returns heat map plot and a matrix. The matrix contains z-scores for consecutive time points, where values above the significanceTh are set to NA
resWithOnlySignif <- plotZP(glmTukeyForEachClus.summary, significanceTh=0.001) ## See Fig. 2
```

![Heatmap](images/Ge/ge_heatmap.png)
Fig. 2: Heatmap showing z-scores for each of the clusters (x-axis) at time-intervals (y-axis) with significant p-values. Z-scores at non-significant intervals are shown in grey.

#### 4. Determine events

To calculate events, the first step involves calculating event windows. Event windows are time-regions calculated from Tukey contrasts (previous step). They are non-overlapping intervals with the maximal change, such that change in subintervals must also be in the the direction of the maximal change. The event windows can be filtered by either the z-score or the p-value or both.

Within each event window, an event must necessarily occur (because of the above properties). For each type of event (increasing or decreasing) an abundance threshold is defined, at which the precise event occurs. The threshold can be set to any value between 0 (minimal abundance for an increasing event, and vice versa for decreasing event) and 1 (maxmimal abundance for an increasing event, and vice versa for decreasing event) and reflects on the users intuition or understanding of the system, such as, what percent concentration (saturation) must be attained for the involved genes to contribute to the underlying mechanisms.



In the example below however, for both gene expression and repression, the events are defined at the 50% standardized expression threshold.

```R
# Returns a list of matrices containing the computed event windoes for each cluster.
eventWindows <- getTimeRegionsWithMaximalChange(glmTukeyForEachClus, 7, 0.05, phosZscoreTh=15, dephosZscoreTh=-15)


# Returns a matrix containing event information, computed for the cluster centroids.  
mat_events <- calcEvents(eventWindows, mfuzzObj$cluster, ge.stand)


# Running the function below is optional, its results may assist in updating thresholds to exclude/include events; It returns a matrix containing the number and percentage of profiles which get removed from an event's distribution because these profiles may not follow the general 'differences in means' direction.
mat_missingStats <- missingStats(ge.stand, mfuzzObj$cluster, mat_events, 0.5, 0.5)

 # Plot clusters and events (here, the events shown computed for the cluster centroids only).
plotClusters_withEvents(ge.stand, mfuzzObj$cluster, mat_events) ## See Fig. 3.

# Produces a heat map with events marked, and returns a matrix (similar to the `plotZP` function).
resWithOnlySignif <- plotZP_withEvents(glmTukeyForEachClus.summary, mat_events, 0.001) ## See Fig. 4.

```
![Clusters with events](images/Ge/ge_clusters_events.png)
Fig. 3: The 20 clusters with 32 events overlaid.

![Clusters with events](images/Ge/ge_heatmap_events.png)
Fig. 4: Heatmap of z-scores with events overlaid.

#### 5. Order filtered(/unfiltered events).
Order events (using mean (use `t-test`) or median (use `wilcox`)) & plot. To determine which test to use, again visually inspect the PDF file generated by the `eventDistributions` function. If the distributions are approximately normally, then use the `t-test`, otherwise use the `wilcox` test.

```R
# Plots distributions of event times for events in each cluster
eventDistributions(ge.stand, mfuzzObj$cluster, mat_events, 0.5, 0.5, outfile="ge_eventDist.pdf"); # See file: images/Ge/ge_eventDist.pdf

# Returned is an object containing information regarding the event and cluster order.
theOrder <- calculateOrder(ge.stand, mfuzzObj$cluster, mat_events, "wilcox")

#The order is can then be plotted using event maps (top) and event sparklines (bottom). The event sparkline is a summary of the order shown in the event map.
visualizeOrder(theOrder) ## See Fig. 5.

```

![Clusters with events](images/Ge/ge_ordered.png)
Fig. 5: Event map (top) and event sparkline (bottom) showing the temporal order of events and clusters.




#### 6. Rearrange clusters

Once the order is generated, the clusters can then be rearranged. For this purpose we make available the function `rearrangeCluster`.

```R

# Returns the clusters rearranged according to the calculated temporal order.
clustersRearranged <- rearrangeClusters(mfuzzObj$cluster, theOrder)
```

Once rearranged, the event map and the event sparkline can be replotted to see the clusters numbered by occurrence of their corresponding first event.

```R
# Then, simply recompute everything as previously, albeit with the new ordering.
glmTukeyForEachClus.rearranged <- calcClusterChng(ge.stand, clustersRearranged)
glmTukeyForEachClus.summary.rearranged <- summaryGetZP(glmTukeyForEachClus.rearranged, ge.stand)

eventWindows.rearranged <- getTimeRegionsWithMaximalChange(glmTukeyForEachClus.rearranged, 7, phosZscoreTh=15, dephosZscoreTh=-15)
mat_events.rearranged <- calcEvents(eventWindows.rearranged, clustersRearranged, ge.stand)


theOrder.rearranged <- calculateOrder(ge.stand, clustersRearranged, mat_events.rearranged, "wilcox")
visualizeOrder(theOrder.rearranged) ## See Fig. 6

# Additionally, cluster plots and heat map plots can also be generated.
```


![Event map and event sparkline](images/Ge/ge_ordered_rearranged.png)
Fig. 6: Rearranged clusters and events (to reflect on the order of occurrence of events).



As a side note, generated images can be saved as PDF and the width and height adjusted:

```R
pdf("ge_dups_wilcox.pdf", width = 16, height=4)
plotClusters(ge.stand, mfuzzObj$cluster)
dev.off()
```


References

1. Ma, X., Yang, P., Kaplan, W.H., Lee, B.H., Wu, L.E., Yang, J.Y.H., Yasunaga, M., Sato, K., Chisholm, D.J. and James, D.E., 2014. ISL1 Regulates Peroxisome Proliferator-Activated Receptor gamma Activation and Early Adipogenesis via Bone Morphogenetic Protein 4-Dependent and-Independent Mechanisms. *Molecular and cellular biology*, 34(19), pp.3607-3617.
